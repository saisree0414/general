/* Jenkins Declarative Pipeline to build and deploy DB MC Queue Listener. The pipeline can be used to deploy the 
* application to c2c environment or to a dev/sandbox RKS environment or to a managed environment. 
* 
* Job name format: 
* 	rrkbk-positions-api_dev_<dev_environment_name> to deploy the application to dev environment cluster
* 	rrkbk-positions-api_int_yy.mm to deploy the application to INT environment 
* 	rrkbk-positions-api_acp_yy.mm to deploy the application to ACP environment
*
* The job uses 'develop' branch for all repos in INT environment and release/yy.mm for ACP environment.
* By default, 'develop' is used for dev environment. However, branch names can be overridden in the
* environment variables: GIT_CONFIG_BRANCH, GIT_APP_BRANCH
*
* PORT
*/
 
@Library(["eire-pipeline-global-utilities", "eire-pipeline-utility-steps@develop"]) _


JENKINS_USER = "user"
JENKINS_NODE_LABEL = "RE_UBUNTU_DEV"

def builduploadhelm(String helmDir, String helmChartPath, String buildVersion) {
	withCredentials([usernamePassword(credentialsId: "${env.ARTIFACTORY_CREDENTIALS_ID}", 
	                                  passwordVariable: 'PASSWORD', usernameVariable: 'USERNAME')]) {
	   	dir ("${helmDir}") {
		  	sh ("""
				pwd
			 	sed -i -e s/#CHART_NAME#/${env.APP_HELM_CHART_NAME}/g Chart.yaml
			 	sed -i -e s/#CHART_VERSION#/${env.BUILD_VERSION}/g Chart.yaml
			 	sed -i -e s/#IMAGE_VERSION#/${env.BUILD_VERSION}/g values.yaml
		  		""")
		  	sh ("""
			 	export PATH=/:\${PATH}
			 	helm package ./
		  		""")
	   		script {
		  		utility.validateArtifact("", "helm-prereleases/${helmChartPath}-${buildVersion}.tgz")
	   		}
	   		
			rtServer (
		   		id: "----artifactory-server", 
		   		url: "https://artifactory.---.com", 
		   		credentialsId: "${env.ARTIFACTORY_CREDENTIALS_ID}"
			)
			
	   		rtUpload (
		  		serverId: "----artifactory-server",
			 	spec: """{
			 			"files": [{
									"pattern": "./*.tgz",
									"target": "helm-prereleases/${helmChartPath}-${buildVersion}.tgz"}
					  			 ]
				   		}"""
	   		)
   	   }
	}
}
/*
*/	
pipeline {
    agent {
        label "${JENKINS_NODE_LABEL}"
    }
   
    
    stages {
		stage("Setup Pipeline Env") {
			steps {
				script {
                    // Email build result to the following CC list, semicolon separate
                    // example: EMAIL_CC_LIST = "a234776@---.com; a580012@---.com; a565051@---.com"
                    env.EMAIL_CC_LIST = "a665528@---.com"
					
					// Application information
 					env.APP_NAME="rrkbk-positions-api"
					env.APP_ID="ap137552"
					env.DEPLOY_ENVIRONMENT="DEV"
					
                    // Source Code
                    env.GIT_APP_URL = "ssh://git@itec-stash.---.com/pr174143/ap137552-positions.git"
                    env.GIT_APP_BRANCH = "develop"
					
                    // Build Version
                    env.MAJOR_MINOR_VERSION = "1.0"
					env.BUILD_VERSION = "${env.MAJOR_MINOR_VERSION}.${env.BUILD_NUMBER}"
					

                    // Execute Maven compile
					env.PROJECT_FOLDER = "${WORKSPACE}"
                    env.MVN_BASE = "${env.PROJECT_FOLDER}"
                    env.MVN_POM = "${env.MVN_BASE}/pom.xml"
                	env.MVN_OPTIONS = "clean install"
                    env.MVN_DEPLOY_JAR = "true"
					env.CONFIG_FOLDER = "${env.MVN_BASE}/positionsConfig"
                    
                    // Execute Sonar for code quality and quality gate analysis
                    env.EXECUTE_SONAR = "true"
                    env.EXECUTE_SONAR_QUALITY_GATE = "true"
                    env.SONARQUBE_ENV_NAME = "sonar_prod_with_token"
                    env.SONAR_MVN_OPTIONS = "sonar:sonar -P sonar-java"
                    
                    // Execute Docker build and push
                    env.EXECUTE_DOCKER_BUILD_PUSH = "true"
					env.ARTIFACTORY_FOLDER = "----${env.APP_ID}"
                    env.DOCKER_IMAGE_NAME = "${ARTIFACTORY_FOLDER}/${env.APP_NAME}".toLowerCase()
                    env.DOCKER_IMAGE_TAG = "${env.BUILD_VERSION}"
                    env.DOCKERFILE_PATH = "${env.PROJECT_FOLDER}"

                    // Execute Git tagging, Can be tagged true for NP env
                    env.EXECUTE_GIT_TAGGING = "true"  
                    env.GIT_TAG_NAME = "${env.BUILD_VERSION}"

					//Execute Helm build and push
					env.HELM_DIR = "${WORKSPACE}/helm"
					env.EXECUTE_HELM_PACKAGE = "true"
					env.APP_HELM_CHART_NAME = "${env.APP_ID}-${env.APP_NAME}".toLowerCase()		
					env.HELM_CHART_PATH = "${env.ARTIFACTORY_FOLDER}/${env.APP_HELM_CHART_NAME}".toLowerCase()
  				   	env.CONFIG_HELM_CHART_NAME = "${env.APP_HELM_CHART_NAME}-config-${DEPLOY_ENVIRONMENT}".toLowerCase() 
					env.CONFIG_HELM_DIR = "${env.CONFIG_FOLDER}/helm/${env.APP_NAME}-config"
					
					//Jenkins Display
                   	currentBuild.displayName = "${env.BUILD_VERSION}"
                    currentBuild.description = "${env.GIT_APP_BRANCH}"
                    
					// K8S Deployment
					env.EXECUTE_K8S_DEPLOYMENT = "true"					
					env.K8S_DEPLOY_ENVIRONMENT = "${env.DEPLOY_ENVIRONMENT}".toLowerCase() 
	               	env.K8S_DEPLOYMENT_NAME = "${env.APP_HELM_CHART_NAME}"
	               	env.K8S_CONFIGMAP_NAME = "${env.APP_HELM_CHART_NAME}-config-${env.K8S_DEPLOY_ENVIRONMENT}"
	               	env.IMAGE_REGISTRY = "fcr-nonprod.---.com"
					// Set Client Master Default envrionment variables
					setClientMasterDefaultVariableInEnv()
					
					
					//Params Required for AKS deployment, these variable can change at Environment level, hence can be made as Jenkins parameters
					//So that same jenkins fiel can be used accross all environmnets and required variables can be selected in jenkins jobs created to specific env.
					
					env.K8S_CSP = "azure"
					env.K8S_NAMESPACE = "pr174143-aks-ns-dev"
					
					env.EXECUTE_SMOKE_QA = false
					
					env.AKS_Credentials = "dab12ca7-593e-4e9d-9dab-2821c03fcc03"
					
                    rtServer (
                        id: "----artifactory", 
                        url: "https://artifactory.---.com", 
                        credentialsId: "${env.ARTIFACTORY_CREDENTIALS_ID}"
                    )
                    rtMavenDeployer (
                        id: "MAVEN_DEPLOYER",
                        serverId: "----artifactory",
                        deployArtifacts: "${env.MVN_DEPLOY_JAR}",
                        releaseRepo: "maven-prereleases-local",
                        snapshotRepo: "maven-prereleases-local"
                    )
                    rtMavenResolver (
                        id: "MAVEN_RESOLVER",
                        serverId: "----artifactory",
                        releaseRepo: "maven-prereleases",
                        snapshotRepo: "maven-prereleases"
                    )
                    // Artifactory closure to capture "build-info".  This is a best practice for audit and traceability.
                    // NOTE: "maxBuilds" and "deleteBuildArtifacts" show how artifacts can be deleted in Artifactory
                    // fully controlled by your job.
                    rtBuildInfo (
                        captureEnv: true,
                        excludeEnvPatterns: ["*private*", "internal-*"],
                        maxBuilds: 90,
                        maxDays: 180,
                        // Optional - delete the build artifacts when deleting a build.
                        deleteBuildArtifacts: true
                    )                    
				}
			}
		}

		stage("Checkout Source Code") {
            steps {
			deleteDir()
			script{
                def scmVars = checkout (
                    changelog: true, poll: true, 
                    scm: [
                        $class: 'GitSCM', 
                        branches: [[name: "${env.GIT_APP_BRANCH}"]], 
                        doGenerateSubmoduleConfigurations: false, gitTool: 'Default', submoduleCfg: [], 
                        userRemoteConfigs: [[credentialsId: "${env.GIT_CREDENTIAL_ID}", url: "${env.GIT_APP_URL}"]]
                    ]
                )
				env.CAPTURE_GIT_SHA = scmVars.GIT_COMMIT
                echo "${env.CAPTURE_GIT_SHA}"
						
            }
        }
		}

		stage("Maven Build") {
            agent {
                docker {
                    image "fcr.---.com/maven:3.6-jdk-11"
                    args  "-v /home/${JENKINS_USER}:/home/${JENKINS_USER} -v /etc/passwd:/etc/passwd -v /bld/${JENKINS_USER}:/bld/${JENKINS_USER} --entrypoint=''"
                    reuseNode true
                }
            }
            environment { 
                MAVEN_HOME = "/usr/share/maven"
            }
			steps {
                rtMavenRun (
                    pom: "${env.MVN_POM}",
                    goals: "versions:set -DnewVersion=${env.BUILD_VERSION}",
                    deployerId: "MAVEN_DEPLOYER",
                    resolverId: "MAVEN_RESOLVER"
                )
                rtMavenRun (
                    pom: "${env.MVN_POM}",
                    goals: "${env.MVN_OPTIONS}",
                    deployerId: "MAVEN_DEPLOYER",
                    resolverId: "MAVEN_RESOLVER"
                )
                rtPublishBuildInfo (
                    serverId: "----artifactory"
                )
				sh("""
               	   cp -f "${env.MVN_BASE}/target/${env.APP_NAME}-${BUILD_VERSION}.jar" "${env.DOCKERFILE_PATH}/${env.APP_NAME}.jar"
            	   """
        	   	)	
				sh("""
               	   cp -f "${env.MVN_BASE}/target/lib/"dd-java-agent*.jar "${env.DOCKERFILE_PATH}/dd-java-agent.jar"
            	   """
        	   	)
			}
		}
		stage("Sonar Scan") {
            when {
                expression {
                    EXECUTE_SONAR == "true"
                }
            }
            environment {
                MAVEN_HOME = "/usr/share/maven"
            }
            agent {
                docker {
                    image "fcr.---.com/maven:3.6-jdk-11"
                    args  "-v /home/${JENKINS_USER}:/home/${JENKINS_USER} -v /etc/passwd:/etc/passwd -v /bld/${JENKINS_USER}:/bld/${JENKINS_USER} --entrypoint=''"
                    reuseNode true
                }
            }
            steps {
                withSonarQubeEnv(env.SONARQUBE_ENV_NAME) {
                    rtMavenRun (
                        pom: "${env.MVN_POM}",
                        goals: "${env.SONAR_MVN_OPTIONS}",
                        deployerId: "MAVEN_DEPLOYER",
                        resolverId: "MAVEN_RESOLVER"
                    )
                }
            }
        }
 
        stage("Sonar Quality Gate") {
            when {
                expression {
                    EXECUTE_SONAR_QUALITY_GATE == "true"
                }
            }
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    script {
                        def qg = waitForQualityGate()
                        if (qg.status != 'OK' && qg.status != 'WARN') {
                            error "Pipeline aborted due to quality gate failure: ${qg.status}"
                        }
                    }
                }
            }
        }
        stage("Build & Push Docker Image") {
            when {
                expression {
                    EXECUTE_DOCKER_BUILD_PUSH == "true"
                }
			}
			steps {
				script {
                   	docker.withRegistry(env.ARTIFACTORY_REGISTY_URL, env.ARTIFACTORY_CREDENTIALS_ID) {
                        utility.validateArtifact("docker-prereleases", "${env.DOCKER_IMAGE_NAME}/${env.DOCKER_IMAGE_TAG}")
                        def tagPrefix = "com.---." + "${env.APP_ID}".toLowerCase() + "." + "${env.DOCKER_IMAGE_NAME}".split("/")[1]
                        def labelCmd = "--label ${tagPrefix}.applicationid=${env.APP_ID} " +
                                       "--label ${tagPrefix}.createdby=${JENKINS_USER} " +
                                       "--label ${tagPrefix}.scmurl=${env.GIT_APP_URL} " +
                                       "--label ${tagPrefix}.scmcommit=${env.CAPTURE_GIT_SHA} " +
                                       "--label ${tagPrefix}.jenkinsurl=${BUILD_URL} "
                        appsImage = docker.build(env.DOCKER_IMAGE_NAME, "${labelCmd} ${env.DOCKERFILE_PATH}")
                        env.appsImageTag = appsImage.tag(env.DOCKER_IMAGE_TAG)
						}
						}
				rtDockerPush (
                    serverId: "----artifactory",
                    image: "${env.appsImageTag}",
                    targetRepo: "docker-prereleases-local"
                )
                rtPublishBuildInfo (
                    serverId: "----artifactory"
                )
                }
            }
        
				
		stage("Git Tagging") {
            when {
                expression {
                    EXECUTE_GIT_TAGGING == "true"
                }
            }
			steps {
                sh("""
                    git tag ${env.GIT_TAG_NAME}
                    git push origin ${env.GIT_TAG_NAME}
                """)
			}
		}
       
		stage("Package and Upload Deployment APP Helm Chart") {
         	when {
            	expression {
                	EXECUTE_HELM_PACKAGE == "true"
            	}
         	}
         	agent {
            	docker {
                	image "fcr.---.com/----ap131374/kconnect-***:0.5.2"
                  	args  "-u root --entrypoint=''"
                  	reuseNode true
            		}
         	}
         	steps {
		    	script {builduploadhelm(env.HELM_DIR, env.HELM_CHART_PATH, env.BUILD_VERSION)}
			}
      	}
		
		stage("Deploy Application to AKS") {
 			when {
            	expression {
               	EXECUTE_K8S_DEPLOYMENT == "true"
            	}
         	}
         	agent {
            	docker {
               		image "fcr.---.com/----ap131374/kconnect-***:0.5.2"
                  	args  "-u root --entrypoint=''"
                  	reuseNode true
            	}
         	}
         	steps {
            	withCredentials([
               		usernamePassword(credentialsId: env.AKS_Credentials, passwordVariable: 'AKS_PASSWORD', usernameVariable: 'AKS_USER'),
		       		usernamePassword(credentialsId: env.ARTIFACTORY_CREDENTIALS_ID, passwordVariable: 'ARTIFACTORY_PASSWORD', usernameVariable: 'ARTIFACTORY_USER')]) {
		       		
                  	sh ('''
                     	export PATH=/:\${PATH}
			export http_proxy="http://http.proxy.---.com:8000"
			export https_proxy="http://http.proxy.---.com:8000"
						
			kconnect use aks --idp-protocol aad --no-input --tenant-id 7521acbc-a68c-41e5-a975-1cf83066dd19 --subscription-id b0406e5b-41e2-45a9-8475-7cbba823df9f --cluster-id b0406e5b-41e2-45a9-8475-7cbba823df9f/wi-pl203388-prdc-aks-dev-eastus2-workload/prdc-aks-dev-eastus2 --username ${AKS_USER}@---.com --password ${AKS_PASSWORD} --login-type token
			kubectl config set-context --current --namespace="${AKS_NAMESPACE}"
						
						
                     	helm repo add ----artifactory https://artifactory.---.com/helm-prereleases \
                         	--username ${ARTIFACTORY_USER} --password ${ARTIFACTORY_PASSWORD}
                     	helm repo update

			# Install Helm chart for config
                        helm search repo ----artifactory/${CONFIG_HELM_CHART_NAME}
                        helm upgrade --install --atomic ${K8S_CONFIGMAP_NAME} ----artifactory/${CONFIG_HELM_CHART_NAME} \
                          --namespace=${K8S_NAMESPACE} --debug \
                          --set environment.csp="${K8S_CSP}" \
                          --set environment.namespace="${K8S_NAMESPACE}" \
                          --set environment.name="${K8S_DEPLOY_ENVIRONMENT}"
                        
                      	if [ $? -ne 0 ]; then
                            echo "ERROR: Failed to install the configmap, exiting..."
                            exit 1
                      	fi
                        
                     	# Install Helm chart for application  
                     	helm search repo ----artifactory/${APP_HELM_CHART_NAME}
                     	echo "$PWD"
                     	helm upgrade --install --atomic ${K8S_DEPLOYMENT_NAME} ----artifactory/${APP_HELM_CHART_NAME} \
					 		--namespace=${K8S_NAMESPACE} --version ${BUILD_VERSION} --debug \
							--set config.name="${K8S_CONFIGMAP_NAME}" \
					 		--set environment.deploy_timestamp="$(date +%s)" \
					 		--set environment.name="${K8S_DEPLOY_ENVIRONMENT}" \
					 		--set environment.namespace="${K8S_NAMESPACE}" \
					 		--set image.registry="${IMAGE_REGISTRY}" \
					 		--set image.repository="${DOCKER_IMAGE_NAME}" \
							--set blueGreen.enabled="false"
							
						# Rollback configmap if application install failed
						if [ $? -ne 0 ]; then
							echo "ERROR: Failed to install the application, rolling back the configmap"
							helm rollback ${K8S_CONFIGMAP_NAME} --namespace=${K8S_NAMESPACE}
							exit 1
						else
							echo "SUCCESS: Successfully installed the application"
						fi
							
                     ''')
           		}
         	}
      	}
		stage("Trigger Smoke QA") {
         	when {
            	expression {
               	EXECUTE_SMOKE_QA == "true"
    			}
     		}
         	steps {
            	echo "Executing Smoke test job"
     		}
      	}
    }
	post {
        always {
			emailext (
                recipientProviders: [[$class: 'RequesterRecipientProvider']],
                subject: "Jenkins Build ${currentBuild.currentResult}: Job ${env.JOB_BASE_NAME}",
				to: "${env.EMAIL_CC_LIST}",
                mimeType: "text/html",
                body: utility.getEmailTemplate()
            )
        }
    }

}
